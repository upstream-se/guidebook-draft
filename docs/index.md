# Upstream Software Engineering

> This page introduces the guidebook for the practice of Upstream Software Engineering, the epistemic governance of the intent of long-lived software systems.

Upstream Software Engineering is the practice of epistemic governance of the intent of long-lived software systems.

Long-lived software systems are enduring socio-technical entities whose governing commitments persist across initiatives, teams, technological shifts, and organizational restructuring.  Yet the knowledge that defines their intent — their commitments about scope, structure, constraints, and non-goals — is often fragmented or implicit.

When those commitments are not explicitly governed, intent fragments, drifts, or is repeatedly reconstructed.  Evolution then becomes increasingly effortful and uncertain, as the commitments that define what must remain valid lose clarity and continuity.

Upstream Software Engineering addresses this condition.  It establishes durable and revisable commitments about scope and structure, clarifies authority and stewardship over those commitments, and defines the conditions under which change is considered valid.  It governs intent without prescribing implementation.

The discipline complements development methodologies, architectural practices, and operational frameworks.  It does not replace them.  Instead, it provides the normative reference within which downstream realization and long-term evolution remain coherent across time..


## About this guidebook

This guidebook is the reference articulation of the practice of Upstream Software Engineering.

It defines the conceptual and normative framework of the discipline, including its formal definitions, metamodel, and valid transformation patterns.  It distinguishes between normative content, which establishes what is considered valid upstream, and non-normative guidance, which supports enactment in practice.

The guidebook is structured to support clarity, interpretation, and disciplined evolution of the practice over time.


## How the guidebook is organized

The guidebook is organized in four main parts:

- **[Motivation](./motivation/)**  
  Explains why a distinct upstream discipline is necessary and frames the problem space.

- **[Foundations](./foundations/)**  
  Defines the discipline, its formal definitions, metamodel, and valid transformation plays.

- **[Guidelines](./guidelines/)**  
  Provides non-normative recommendations for enacting the discipline in practice.

- **[Resources](./resources/)**  
  Offers reusable materials that support learning, application, and dissemination of the discipline.


## How to read this guidebook

This guidebook is not intended to be read linearly.  It is structured as a reference that supports selective and iterative use.

Readers should consult **Motivation** to understand the problem space, use **Foundations** to assess what is considered valid within the discipline, and refer to **Guidelines** for recommended ways of enacting the normative core in practice.  **Resources** provide supporting materials.

Only the content in **Foundations** defines validity.  **Guidelines** are non-normative, and **Motivation** and **Resources** are informative.  Understanding these distinctions is essential for correct use of the guidebook.

↘ Refer to **[How to read this guidebook](./how-to-read-this-guidebook.md)**
  Defines how to understand and use the guidebook, including its structure, normativity, and compliance.


## Guidebook versioning and evolution

The guidebook evolves through structured versioning to ensure stability and traceability over time.

Each major version represents a distinct normative state of the discipline, defined by its **Foundations**.  Once released, a major version is stable and remains a valid reference.  Subsequent changes that alter the normative core result in a new major version.

Minor versions refine or clarify content without changing the normative core.  Editorial corrections that do not affect meaning may be introduced as patches.

Normative claims and compliance assessments must identify the major version to which they refer, since prior major versions remain available as stable historical reference states.


## Contributing

The guidebook evolves through structured and governed contributions.

Proposals for clarification, refinement, extension, or correction are welcome across all parts of the guidebook. Changes to the normative core defined in **Foundations** undergo stricter review due to their impact on validity and versioning.

All contributions are evaluated according to the guidebook governance policies.  These policies define how proposals are submitted, reviewed, classified, and incorporated.

The guidebook is expected to grow as the discipline evolves.  The evolution of the guidebook is governed to ensure coherence and stability.

↗ See **[Guidebook governance](./meta/)** for the governance framework that regulates the structure, authorship, evolution, and authority of the guidebook.


## Intended audience

This guidebook is intended for professionals and researchers involved in the **definition, governance, and long-term evolution of software systems**, including the following.


### Product and technology leadership

- software architects
- technical leads and principal engineers
- product leads and product managers
- engineering managers responsible for product direction


### Governance and organizational roles

- roles responsible for product, portfolio, or architectural governance
- decision-makers defining boundaries, ownership, and accountability
- consultants supporting organizations in software system governance and evolution


### Software Engineering practice (upstream-focused)

- senior software engineers involved in architectural and structural decisions
- practitioners operating across multiple teams, systems, or providers
- roles bridging business intent and technical realization


### Research and education

- researchers studying software systems, evolution, and governance
- educators designing curricula or teaching advanced software engineering topics
- students learning how to govern long-lived software systems

This guidebook assumes familiarity with:

- Software Engineering concepts and terminology
- modern software development practices
- organizational contexts where software systems evolve over time

It is **not intended as an introductory text** to software development.


## How this guidebook relates to practice

Concrete applications of this guidebook — including:

- project-specific documents
- internal working notes
- customer deliverables

exist **outside** this guidebook.

The guidebook defines:

- the conceptual structures
- the valid transformations
- and recommended ways of working

Their instantiation belongs to the context in which they are applied.


## Where to go next

If you are new to the guidebook, proceed in the following order:

1. **[How to read this guidebook](./how-to-read.md)** — to understand interpretation and normativity  
2. **[Motivation](./motivation/index.md)** — to understand why the discipline is needed  
3. **[Foundations](./foundations/index.md)** — to explore the discipline, its metamodel, and its plays  

Use **[Guidelines](./guidelines/index.md)** as a source of inspiration and operational advice.  

Consult **[Resources](./resources/index.md)** for reusable materials you can download or adapt.
