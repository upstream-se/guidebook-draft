# Upstream Software Engineering

> This page introduces the guidebook for the practice of Upstream Software Engineering, the epistemic governance of the intent of long-lived software systems.

Upstream Software Engineering is the practice of epistemic governance of the intent of long-lived software systems.

Long-lived software systems are enduring socio-technical entities whose governing commitments persist across initiatives, teams, technological shifts, and organizational restructuring.  Yet the knowledge that defines their intent — their commitments about scope, structure, constraints, and non-goals — is often fragmented or implicit.

When those commitments are not explicitly governed, intent fragments, drifts, or is repeatedly reconstructed.  Evolution then becomes increasingly effortful and uncertain, as the commitments that define what must remain valid lose clarity and continuity.

Upstream Software Engineering addresses this condition.  It establishes durable and revisable commitments about scope and structure, clarifies authority and stewardship over those commitments, and defines the conditions under which change is considered valid.  It governs intent without prescribing implementation.

The discipline complements development methodologies, architectural practices, and operational frameworks.  It does not replace them.  Instead, it provides the normative reference within which downstream realization and long-term evolution remain coherent across time..


## About this guidebook

This guidebook is the reference articulation of the practice of Upstream Software Engineering.

It defines the conceptual and normative framework of the discipline, including its formal definitions, metamodel, and valid transformation patterns.  It distinguishes between normative content, which establishes what is considered valid upstream, and non-normative guidance, which supports enactment in practice.

The guidebook is structured to support clarity, interpretation, and disciplined evolution of the practice over time.


## How the guidebook is organized

The guidebook is organized in four main parts:

- **[Motivation](./motivation/)**  
  Explains why a distinct upstream discipline is necessary and frames the problem space.

- **[Foundations](./foundations/)**  
  Defines the discipline, its formal definitions, metamodel, and valid transformation plays.

- **[Guidelines](./guidelines/)**  
  Provides non-normative recommendations for enacting the discipline in practice.

- **[Resources](./resources/)**  
  Offers reusable materials that support learning, application, and dissemination of the discipline.


## How to read this guidebook

This guidebook is not intended to be read linearly.  It is structured as a reference that supports selective and iterative use.

Readers should consult **Motivation** to understand the problem space, use **Foundations** to assess what is considered valid within the discipline, and refer to **Guidelines** for recommended ways of enacting the normative core in practice.  **Resources** provide supporting materials.

Only the content in **Foundations** defines validity.  **Guidelines** are non-normative, and **Motivation** and **Resources** are informative.  Understanding these distinctions is essential for correct use of the guidebook.

↘ Refer to **[How to read this guidebook](./how-to-read-this-guidebook.md)**
  Defines how to understand and use the guidebook, including its structure, normativity, and compliance.


## Guidebook versioning and evolution

The guidebook evolves through structured versioning to ensure stability and traceability over time.

Each major version represents a distinct normative state of the discipline, defined by its **Foundations**.  Once released, a major version is stable and remains a valid reference.  Subsequent changes that alter the normative core result in a new major version.

Minor versions refine or clarify content without changing the normative core.  Editorial corrections that do not affect meaning may be introduced as patches.

Normative claims and compliance assessments must identify the major version to which they refer, since prior major versions remain available as stable historical reference states.


## Contributing

The guidebook evolves through structured and governed contributions.

Proposals for clarification, refinement, extension, or correction are welcome across all parts of the guidebook. Changes to the normative core defined in **Foundations** undergo stricter review due to their impact on validity and versioning.

All contributions are evaluated according to the guidebook governance policies.  These policies define how proposals are submitted, reviewed, classified, and incorporated.

The guidebook is expected to grow as the discipline evolves.  The evolution of the guidebook is governed to ensure coherence and stability.

↗ See **[Guidebook governance](./meta/)** for the governance framework that regulates the structure, authorship, evolution, and authority of the guidebook.


## Intended audience

This guidebook is intended for **professionals** responsible for the definition, governance, and evolution of long-lived software systems.

This includes those who define structural commitments, establish system boundaries, govern architectural coherence, and steward long-lived systems across projects, teams, organizational restructurings, providers, and technological change.

Representative roles include enterprise and software architects, technical leads, principal engineers, product leaders, product owners, engineering managers, governance and portfolio roles, consultants, and roles within **software providers** or development organizations responsible for delivering and evolving systems on behalf of others.

The guidebook also serves **educators** and **researchers** in Software Engineering, organizational management and governance, and related fields concerned with system evolution and control.

It is further relevant to researchers and practitioners applying artificial intelligence to software development and evolution, as well as to **organizations adopting AI** in software construction, maintenance, migration, and long-term evolution, where AI-assisted tools and agents must operate within clearly defined structural commitments and governance constraints.

Familiarity with Software Engineering concepts, modern development practices, and organizational contexts in which software systems transcend individual projects, teams, or providers will facilitate effective use of this guidebook.


## Where to go next

If you are new to the guidebook, proceed in the following order:

1. **[How to read this guidebook](./how-to-read.md)** — to understand interpretation and normativity  
2. **[Motivation](./motivation/index.md)** — to understand why the discipline is needed  
3. **[Foundations](./foundations/index.md)** — to explore the discipline, its metamodel, and its plays  

Use **[Guidelines](./guidelines/index.md)** as a source of inspiration and operational advice.  

Consult **[Resources](./resources/index.md)** for reusable materials you can download or adapt.
